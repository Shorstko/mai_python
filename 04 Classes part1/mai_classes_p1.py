# Полиморфизм: в разных объектах одна и та же операция может выполнять различные функции. Например, оператор + для чисел, строк и списков
# Инкапсуляция: можно скрыть ненужные внутренние подробности работы объекта от окружающего мира. "Служебные" атрибуты внутри класса, к которым нет доступа извне
# Наследование: следующий класс создается на базе предыдущего, как его потомок, и берет себе типовые операции этого класса
# Композиция: объект может быть составным и включать в себя другие объекты.

# Объект класса и инстанс класса - это два разных объекта. Первый генерируется на этапе объявления класса, второй - при вызове имени класса. Объект класса может быть один, инстансов класса может быть сколько угодно.

# Обычно первый аргумент в имени метода — self. Как говорит автор языка Гвидо Ван Россум, это не более чем соглашение: имя self не имеет абсолютно никакого специального значения. self полезен для того, чтобы обращаться к другим атрибутам класса

# https://www.ibm.com/developerworks/ru/library/l-python_part_6/index.html
# https://python-scripts.com/python-class

import argparse
import sys

# Упаковываем парсер командной строки в класс
# 1) Создание класса. init. что такое self
# 2) методы. свойства - публичные, приватные, вне класса
# 3) передача параметров

# методы класса можно определять и снаружи класса
# этот метод позволит показать значение конкретного аргумента по его имени
# метод создан для демонстрации. для практического использования было бы оптимальнее сделать
# return vars(self.args)[argname] вместо print
def showArgByName(self, argname):
    print(f"Аргумент: {argname}, значение: {vars(self.args)[argname]}")

class CmdLineParser():
    # публичный аргумент класса
    args = None
    # приватный (скрытый) аргумент - только для внутреннего использования
    __private_args = None
    # вот так можно добавить в класс функцию, определенную снаружи (технически возможно, но лучше так не делать)
    showArgs = showArgByName

    # по умолчанию все атрибуты и методы класса - публичные, доступные извне
    # для того, чтобы их "спрятать" (сделать приватными), впереди нужно добавить два знака подчеркивания: __
    def __create_parser(self):
        parser = argparse.ArgumentParser(description="mai_classes_p1.py")
        parser.add_argument("-digits", type=int, default=4, help=u"Сколько цифр вводить. Например: -digits 4")
        parser.add_argument("--fullsign", default="B", type=str,
                            help=u"Каким символом помечать совпадение по значению и месту. Пример: --fullsign F. По умолчанию B")
        parser.add_argument("--partialsign", default="K", type=str,
                            help=u"Каким символом помечать совпадение по месту. Пример: --partialsign P. По умолчанию K")
        parser.add_argument("--logfile", default="",
                            help=u"Записывать историю ходов в файл (имя файла). Пример: --logfile c:\guessthenumber.log")
        return parser

    # функция инициализации экземпляра класса. можно настроить каждый конкретный экземпляр при его создании
    def __init__(self, sysargs):
        self.parser = self.__create_parser()
        self.args = self.parser.parse_args(sysargs)
        self.__private_args = self.args

    def getArgs(self):
        return self.args

# =============
def main():
    parser = CmdLineParser(sys.argv[1:])
    # документация по атрибуту класса или по самому классу получается при помощи атрибута __doc__
    print(parser.args.__doc__)
    # (закоментированная) команда ниже вызвала бы исключение, т.к. аргумент приватный
    # print(parser.__private_args)
    print(parser.getArgs())
    # получаем результат парсинга командной строки. уже из атрибута класса
    args = vars(parser.getArgs())
    print(f"Аргументы: {args}")
    # тестируем метод, который был определн извне
    print(parser.showArgs("digits"))


if __name__ == "__main__":
    main()

# =============
# Самостоятельно: проектирование класса "Игра" (базовый)
class Game:
    def __init__(self, name, players=1):
        self.name = name


game = Game("Типовая игра")
print(game.name)

game.players = 2
print(game.players)
