# ==================
# МАТЧАСТЬ
# информация о квартирах хранится в файле csv. одна строка = одна квартира
# первая строка (с индексом 0) - заголовок вот такого вида:
# ID;Количество комнат;Новостройка/вторичка;Метро;Время до метро;Способ;Адрес;Площадь, м2;Этаж;Этажей;Цена;Описание;Балкон;Окна;Санузел;Год постройки;Лифт;Ссылка на объявление
# всего в файле 1 строка-заголовок и 203 строки-квартиры
# ==================
# СПРАВОЧНИК
# списки https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html
# словари https://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html
# множества https://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html
# кортежи https://pythonworld.ru/tipy-dannyx-v-python/kortezhi-tuple.html
# хорошая статья про f-строки: https://realpython.com/python-f-strings/
# диаграмма Венна https://ru.wikipedia.org/wiki/Диаграмма_Венна
# очень понятная визуализация теории множеств :) https://static.tildacdn.com/tild3761-6332-4239-a166-306134646164/20180123_084944.png
# ==================

# читаем информацию о квартирах в список flats_list. это список списков:
# [[header], [flat1], [flat2], ..., [flatN]]
import csv
flats_list = list()
with open('output.csv', encoding="utf-8") as csvfile:
	flats_csv = csv.reader(csvfile, delimiter=';')
	flats_list = list(flats_csv)

# для работы с данными нам сначала нужно убрать заголовок
# его можно просто удалить безвозвратно. В функцию del необходимо передать тот элемент списка, который нужно удалить. flats_list[3], например, удалит 4ю запись
del(flats_list[0])
# либо можно "вынуть" заголовок. т.е. удалить его из flats_list, но при этом сохранить в переменной. В функцию pop передается индекс нужного элемента. pop(3), например, удалит 4ю запись
header = flats_list.pop(0)

# вот так мы получаем информацию об одной из квартир (первая по счету)
print(flats_list[0])
# вот так мы получаем один из элементов для первой квартиры (по индексу 11 лежит цена квартиры)
print(flats_list[0][11])

# ==================
# ищем квартиру, которую мы можем себе позволить
# алгоритм: пользователь вводит свой бюджет, в цикле печатаются все квартиры, стоимость которых не больше указанной
# ВАЖНО:
# 1) для преобразования строки в число используйте функцию int("ваша строка")
# 2) по списку можно ходить в обе стороны: и  от начала к концу, т.е. от 0 до N, и от конца к началу, от N до 0. Сравните:
# [a, b, c, d, e, f]
#  0, 1, 2, 3, 4, 5
# -6,-5,-4,-3,-2,-1
while True:
	user_input = input("Введите ваш бюджет. Если хотите закончить, введите q\n")
	if user_input == "q":
		break
	budget = int(user_input)

	for flat in flats_list:
		if int(flat[11]) <= budget:
			print(f"Квартира {flat[0]} нам подходит, посмотреть можно по ссылке {flat[-1]}")

# в примере выше использовались так называемые f-строки
# в python есть 3 способа вывода строк:
# 1) традиционный, почти как в С++
# важно: в такой записи можно визуально форматировать вывод (делать отступы), пример для типа float: https://repl.it/@shorstko/Formatirovaniie-chisiel-s-plavaiushchiei-tochkoi
print("Квартира %s нам подходит, посмотреть можно по ссылке %s" % (flat[0], flat[-1]))
# 2) более удобный через функцию format. Кстати, этой функцией можно собирать строки по частям в любых случаях, не только в print
print("Квартира %s нам подходит, посмотреть можно по ссылке %s".format(flat[0], flat[-1]))
# 3) f-строки. Почти так же, как через format, только короче
print(f"Квартира {flat[0]} нам подходит, посмотреть можно по ссылке {flat[-1]}")

# ==================
# множества (set) нужны для быстрого сопоставления больших наборов объектов. множество содержит только уникальные элементы и само следит, чтобы не появлялись дубли. порядок элементов множества задает python, не вы!
# пример, когда нужны множества: определим, у каких станций метро расположены наши квартиры и научимся быстро проверять, есть ли станции метро, которые нас интересуют, в этой выборке
# создаем пустое множество
subway_set = set() 
for flat in flats_list:
  # в исходном файле у нас запись "м.Черкизовская". давайте избавимся от "м.":
	subway = flat[3].replace("м.", "")
  # добавляем следующее метро в множество. оно само проследит, чтобы не было дублей
	subway_set.add(subway)
# смотрим, сколько станций метро в нашей выборке квартир
print(subway_set)
# мы хотим проверить, есть ли вот такие метро в выборке квартир.
# ВНИМАНИЕ! конструктор множества принимает только один аргумент! поэтому в него нужно положить список, а вот строки через запятую туда отправить нельзя
test_set = set(["Селигерская", "Маяковская", "Сокол","Выхино","Черкизовская"])
# проверяем, какие из наших метро были в исходной выборке. 2 способа: через & и через метод intersection множества. обратите внимание, как пишется второй случай
print(subway_set & test_set)
print(subway_set.intersection(test_set))
# ЗАДАНИЕ: изучите сами, как работают две операции разности множеств: set.difference и set.symmetric_difference https://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html

# ==================
# словари незаменимы в обработке и хранении данных. они очень напоминают JSON :)
# пример: сделаем так, чтобы можно было быстро подбирать квартиры, если мы знаем, какое нам нужно метро. создаем словарь, где ключ - это название метро, а значения - список из квартир. для простоты в наш список положим только ID квартиры на ЦИАНе (flat[0]).
# ВНИМАНИЕ! чтобы поместить что-то в список, нужно сначала его создать. дальше два примера, как это сделать: 1) через ручную проверку, есть ли уже такой ключ в словаре (т.е. список уже успели создать), либо, если нет, то сначала создаем список; 2) через метод словаря setdefault, который сам все проверит за нас и при необходимости создаст пустой список
# способ №1
flats_dict = {}
for flat in flats_list:
	subway = flat[3].replace("м.", "")
  # flats_dict.keys() - это все ключи словаря. 
  # посмотрите, что это за тип данных: print(type(flats_dict.keys()))
	if subway not in flats_dict.keys():
		flats_dict[subway] = list()
	flats_dict[subway].append(flat[0])
# способ №2
flats_dict = {}
for flat in flats_list:
	subway = flat[3].replace("м.", "")
  # одна строчка вместо двух. в функции setdefault первый параметр - название метро, второй - значение "по умолчанию", т.е. наш пустой список
	flats_dict.setdefault(subway, list())
	flats_dict[subway].append(flat[0])
